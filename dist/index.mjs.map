{"version":3,"sources":["../src/actions/arbitrageAction.ts","../src/providers/marketProvider.ts","../src/config/thresholds.ts","../src/core/addresses.ts","../src/core/utils.ts","../src/core/Arbitrage.ts","../src/services/ArbitrageService.ts","../src/index.ts"],"names":["ServiceType","BigNumber","Wallet"],"mappings":";;;;;;;;;;AAGO,IAAM,sBAAiC,GAAA;AAAA,EAC1C,IAAM,EAAA,mBAAA;AAAA,EACN,OAAA,EAAS,CAAC,iBAAA,EAAmB,eAAe,CAAA;AAAA,EAC5C,WAAa,EAAA,yCAAA;AAAA,EAEb,QAAA,EAAU,OAAO,OAAA,EAAwB,QAAqB,KAAA;AAE1D,IAAO,OAAA,OAAA,CAAQ,UAAW,CAAA,4BAA4B,CAAM,KAAA,SAAA;AAAA,GAChE;AAAA,EAEA,OAAA,EAAS,OAAO,OAAA,EAAwB,QAAqB,KAAA;AACzD,IAAA,MAAM,OAAU,GAAA,OAAA,CAAQ,UAAW,CAAA,WAAA,CAAY,SAAS,CAAA;AACxD,IAAM,MAAA,OAAA,GAAU,MAAM,OAAA,CAAQ,eAAgB,EAAA;AAE9C,IAAI,IAAA,OAAA,CAAQ,SAAS,CAAG,EAAA;AACpB,MAAM,MAAA,OAAA,CAAQ,iBAAiB,OAAO,CAAA;AAAA;AAG1C,IAAO,OAAA,IAAA;AAAA,GACX;AAAA,EAEA,QAAU,EAAA;AAAA,IACN;AAAA,MACI;AAAA,QACI,IAAM,EAAA,WAAA;AAAA,QACN,OAAA,EAAS,EAAE,IAAA,EAAM,8BAA+B;AAAA,OACpD;AAAA,MACA;AAAA,QACI,IAAM,EAAA,WAAA;AAAA,QACN,OAAS,EAAA;AAAA,UACL,IAAM,EAAA,+BAAA;AAAA,UACN,MAAQ,EAAA;AAAA;AACZ;AACJ;AACJ;AAER,CAAA;ACnCO,IAAM,cAA2B,GAAA;AAAA,EACpC,GAAA,EAAK,OAAO,OAAA,EAAwB,QAA8C,KAAA;AAC9E,IAAA,MAAM,OAAU,GAAA,OAAA,CAAQ,UAAWA,CAAAA,WAAAA,CAAY,SAAS,CAAA;AACxD,IAAM,MAAA,OAAA,GAAU,MAAM,OAAA,CAAQ,eAAgB,EAAA;AAE9C,IAAO,OAAA;AAAA,MACH,eAAe,OAAQ,CAAA,MAAA;AAAA,MACvB,WAAa,EAAA,GAAA;AAAA;AAAA,MACb,UAAY,EAAA,iBAAA,IAAI,IAAK,EAAA,EAAE,WAAY,EAAA;AAAA,MACnC,SAAS;AAAC;AAAA,KACd;AAAA;AAER,CAAA;ACPO,IAAM,kBAAuC,GAAA;AAAA,EAChD,kBAAA,EAAoB,SAAU,CAAA,IAAA,CAAK,iBAAiB,CAAA;AAAA;AAAA,EACpD,YAAA,EAAc,SAAU,CAAA,IAAA,CAAK,qBAAqB,CAAA;AAAA;AAAA,EAClD,QAAU,EAAA,GAAA;AAAA,EACV,qBAAuB,EAAA;AAC3B,CAAA;;;ACdO,IAAM,YAAe,GAAA,4CAAA;ACGrB,IAAM,QAAQC,SAAU,CAAA,IAAA,CAAK,EAAE,CAAA,CAAE,IAAI,EAAE,CAAA;ACoBvC,IAAM,YAAN,MAAgB;AAAA;AAAA,EAMnB,WAAA,CACY,MACA,EAAA,iBAAA,EACA,sBACV,EAAA;AAHU,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AACA,IAAA,IAAA,CAAA,iBAAA,GAAA,iBAAA;AACA,IAAA,IAAA,CAAA,sBAAA,GAAA,sBAAA;AARZ,IAAA,IAAA,CAAQ,gBAAkE,EAAC;AAC3E,IAAA,IAAA,CAAQ,UAA+B,GAAA,kBAAA;AACvC,IAAA,IAAA,CAAQ,WAAc,GAAA,CAAA;AACtB,IAAA,IAAA,CAAQ,WAAc,GAAA,GAAA;AAAA;AAMnB,EAEH,MAAM,gBAAgB,cAAiE,EAAA;AACnF,IAAA,WAAA,CAAY,IAAI,+BAA+B,CAAA;AAC/C,IAAA,MAAM,gBAAwC,EAAC;AAE/C,IAAA,KAAA,MAAW,CAAC,YAAc,EAAA,OAAO,KAAK,MAAO,CAAA,OAAA,CAAQ,cAAc,CAAG,EAAA;AAElE,MAAA,MAAM,YAAe,GAAA,MAAM,IAAK,CAAA,kBAAA,CAAmB,SAAS,YAAY,CAAA;AAGxE,MAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,YAAA,CAAa,QAAQ,CAAK,EAAA,EAAA;AAC1C,QAAA,KAAA,IAAS,IAAI,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,YAAA,CAAa,QAAQ,CAAK,EAAA,EAAA;AAC9C,UAAM,MAAA,WAAA,GAAc,MAAM,IAAK,CAAA,yBAAA;AAAA,YAC3B,aAAa,CAAC,CAAA;AAAA,YACd,aAAa,CAAC,CAAA;AAAA,YACd;AAAA,WACJ;AACA,UAAA,IAAI,WAAa,EAAA;AACb,YAAA,aAAA,CAAc,KAAK,WAAW,CAAA;AAAA;AAClC;AACJ;AACJ;AAIJ,IAAA,OAAO,aAAc,CAAA,IAAA,CAAK,CAAC,CAAA,EAAG,CAAM,KAAA,CAAA,CAAE,MAAO,CAAA,GAAA,CAAI,CAAE,CAAA,MAAM,CAAE,CAAA,QAAA,EAAU,CAAA;AAAA;AACzE,EAEA,MAAc,kBAAmB,CAAA,OAAA,EAAsB,YAA4C,EAAA;AAC/F,IAAA,MAAM,eAA4B,EAAC;AACnC,IAAA,KAAA,MAAW,UAAU,OAAS,EAAA;AAC1B,MAAI,IAAA;AACA,QAAA,MAAM,QAAW,GAAA,MAAM,MAAO,CAAA,WAAA,CAAY,YAAY,CAAA;AACtD,QAAA,IAAI,QAAS,CAAA,EAAA,CAAG,IAAK,CAAA,UAAA,CAAW,kBAAkB,CAAG,EAAA;AACjD,UAAA,YAAA,CAAa,KAAK,MAAM,CAAA;AAAA;AAC5B,eACK,KAAO,EAAA;AACZ,QAAA,OAAA,CAAQ,KAAM,CAAA,CAAA,sBAAA,EAAyB,MAAO,CAAA,aAAa,KAAK,KAAK,CAAA;AAAA;AACzE;AAEJ,IAAO,OAAA,YAAA;AAAA;AACX,EAEA,MAAc,yBAAA,CACV,OACA,EAAA,OAAA,EACA,YACoC,EAAA;AACpC,IAAI,IAAA;AAEA,MAAA,MAAM,SAAS,MAAM,OAAA,CAAQ,YAAa,CAAA,YAAA,EAAc,cAAc,KAAK,CAAA;AAC3E,MAAA,MAAM,SAAS,MAAM,OAAA,CAAQ,YAAa,CAAA,YAAA,EAAc,cAAc,KAAK,CAAA;AAG3E,MAAA,MAAM,CAAC,SAAA,EAAW,UAAU,CAAA,GAAI,OAAO,EAAG,CAAA,MAAM,CAC1C,GAAA,CAAC,OAAS,EAAA,OAAO,CACjB,GAAA,CAAC,SAAS,OAAO,CAAA;AAEvB,MAAM,MAAA,MAAA,GAAS,MAAO,CAAA,EAAA,CAAG,MAAM,CAAA,GACzB,MAAO,CAAA,GAAA,CAAI,MAAM,CAAA,GACjB,MAAO,CAAA,GAAA,CAAI,MAAM,CAAA;AAEvB,MAAA,IAAI,MAAO,CAAA,EAAA,CAAG,IAAK,CAAA,UAAA,CAAW,kBAAkB,CAAG,EAAA;AAE/C,QAAA,MAAM,SAAS,MAAM,IAAA,CAAK,uBAAuB,SAAW,EAAA,UAAA,EAAY,cAAc,MAAM,CAAA;AAE5F,QAAO,OAAA;AAAA,UACH,aAAa,CAAC;AAAA,YACV,aAAe,EAAA,SAAA;AAAA,YACf,YAAc,EAAA;AAAA,WACjB,CAAA;AAAA,UACD,MAAA;AAAA,UACA,MAAA;AAAA,UACA,YAAA;AAAA,UACA,aAAe,EAAA,SAAA;AAAA,UACf,YAAc,EAAA;AAAA,SAClB;AAAA;AACJ,aACK,KAAO,EAAA;AACZ,MAAQ,OAAA,CAAA,KAAA,CAAM,yCAAyC,KAAK,CAAA;AAAA;AAEhE,IAAO,OAAA,IAAA;AAAA;AACX,EAEA,MAAM,kBAAA,CACF,OACA,EAAA,YAAA,EACA,WACa,EAAA;AACb,IAAA,KAAA,MAAW,UAAU,OAAS,EAAA;AAC1B,MAAA,KAAA,IAAS,OAAU,GAAA,CAAA,EAAG,OAAW,IAAA,WAAA,EAAa,OAAW,EAAA,EAAA;AACrD,QAAI,IAAA;AACA,UAAA,MAAM,WAAc,GAAA,MAAM,IAAK,CAAA,qBAAA,CAAsB,QAAQ,YAAY,CAAA;AACzE,UAAA,IAAI,WAAa,EAAA;AACb,YAAA,WAAA,CAAY,GAAI,CAAA,CAAA,gCAAA,EAAmC,WAAY,CAAA,IAAI,CAAE,CAAA,CAAA;AAErE,YAAM,MAAA,WAAA,CAAY,KAAK,CAAC,CAAA;AACxB,YAAA;AAAA;AACJ,iBACK,KAAO,EAAA;AACZ,UAAA,OAAA,CAAQ,KAAM,CAAA,CAAA,QAAA,EAAW,OAAO,CAAA,QAAA,CAAA,EAAY,KAAK,CAAA;AACjD,UAAA,IAAI,YAAY,WAAa,EAAA;AACzB,YAAQ,OAAA,CAAA,KAAA,CAAM,mCAAmC,MAAM,CAAA;AAAA,WACpD,MAAA;AACH,YAAA,MAAM,IAAI,OAAQ,CAAA,CAAA,CAAA,KAAK,WAAW,CAAG,EAAA,IAAA,CAAK,WAAW,CAAC,CAAA;AAAA;AAC1D;AACJ;AACJ;AACJ;AACJ,EAEA,MAAc,qBACV,CAAA,MAAA,EACA,WACmC,EAAA;AAEnC,IAAM,MAAA,QAAA,GAAW,MAAM,MAAA,CAAO,aAAc,CAAA,sBAAA;AAAA,MACxC,YAAA;AAAA,MACA,MAAO,CAAA,MAAA;AAAA,MACP,MAAO,CAAA;AAAA,KACX;AAGA,IAAM,MAAA,kBAAA,GAAqB,MAAM,MAAA,CAAO,aAAc,CAAA,YAAA;AAAA,MAClD,YAAA;AAAA,MACA,MAAO,CAAA,YAAA;AAAA,MACP,MAAO,CAAA;AAAA,KACX;AAGA,IAAM,MAAA,YAAA,GAAe,MAAM,MAAA,CAAO,YAAa,CAAA,UAAA;AAAA,MAC3C,MAAO,CAAA,YAAA;AAAA,MACP,kBAAA;AAAA,MACA,KAAK,sBAAuB,CAAA;AAAA,KAChC;AAGA,IAAA,MAAM,UAAU,CAAC,GAAG,SAAS,OAAS,EAAA,MAAA,CAAO,aAAa,aAAa,CAAA;AACvE,IAAA,MAAM,QAAW,GAAA,CAAC,GAAG,QAAA,CAAS,MAAM,YAAY,CAAA;AAGhD,IAAA,MAAM,cAAc,MAAO,CAAA,MAAA,CAAO,IAAI,EAAE,CAAA,CAAE,IAAI,GAAG,CAAA;AAGjD,IAAM,MAAA,MAAA,GAAS,MAAM,IAAK,CAAA,YAAA;AAAA,MACtB,MAAO,CAAA,MAAA;AAAA,MACP,WAAA;AAAA,MACA,OAAA;AAAA,MACA,QAAA;AAAA,MACA;AAAA,KACJ;AAGA,IAAO,OAAA,IAAA,CAAK,sBAAuB,CAAA,MAAA,EAAQ,WAAW,CAAA;AAAA;AAC1D,EAEA,MAAc,YACV,CAAA,MAAA,EACA,WACA,EAAA,OAAA,EACA,UACA,WACsB,EAAA;AAEtB,IAAM,MAAA,WAAA,GAAc,MAAM,IAAK,CAAA,qBAAA;AAAA,MAC3B,MAAA;AAAA,MACA,WAAA;AAAA,MACA,OAAA;AAAA,MACA;AAAA,KACJ;AAGA,IAAA,MAAM,QAAW,GAAA,MAAM,IAAK,CAAA,kBAAA,CAAmB,WAAW,CAAA;AAG1D,IAAA,MAAM,WAAc,GAAA,MAAM,IAAK,CAAA,sBAAA,CAAuB,mBAAoB,CAAA,WAAA;AAAA,MACtE,MAAA;AAAA,MACA,WAAA;AAAA,MACA,OAAA;AAAA,MACA,QAAA;AAAA,MACA,EAAE,QAAU,EAAA,WAAA,EAAa,QAAS;AAAA,KACtC;AAGA,IAAA,MAAM,QAAW,GAAA,MAAM,IAAK,CAAA,MAAA,CAAO,gBAAgB,WAAW,CAAA;AAG9D,IAAA,MAAM,WAAc,GAAA,MAAM,IAAK,CAAA,iBAAA,CAAkB,QAAQ,CAAA;AAEzD,IAAA,OAAO,CAAC,WAAW,CAAA;AAAA;AACvB,EAEA,MAAc,qBAAA,CACV,MACA,EAAA,WAAA,EACA,SACA,QACkB,EAAA;AAClB,IAAA,MAAM,QAAW,GAAA,MAAM,IAAK,CAAA,sBAAA,CAAuB,WAAY,CAAA,WAAA;AAAA,MAC3D,MAAA;AAAA,MACA,WAAA;AAAA,MACA,OAAA;AAAA,MACA;AAAA,KACJ;AACA,IAAA,OAAO,QAAS,CAAA,GAAA,CAAI,GAAG,CAAA,CAAE,IAAI,GAAG,CAAA;AAAA;AACpC,EAEA,MAAc,mBAAmB,WAAyC,EAAA;AACtE,IAAM,MAAA,EAAE,iBAAiB,WAAY,EAAA,GAAI,MAAM,eAAgB,CAAA,IAAA,CAAK,OAAO,QAAoB,CAAA;AAC/F,IAAA,MAAM,SAAY,GAAA,eAAA,CAAgB,EAAG,CAAA,WAAW,IAAI,eAAkB,GAAA,WAAA;AACtE,IAAA,OAAO,SAAU,CAAA,GAAA,CAAI,GAAG,CAAA,CAAE,IAAI,GAAG,CAAA;AAAA;AACrC,EAEA,MAAc,sBACV,CAAA,MAAA,EACA,WACmC,EAAA;AACnC,IAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,IAAA,CAAK,aAAa,CAAK,EAAA,EAAA;AACvC,MAAI,IAAA;AAEA,QAAM,MAAA,IAAA,CAAK,cAAe,CAAA,MAAA,EAAQ,WAAW,CAAA;AAG7C,QAAM,MAAA,QAAA,GAAW,MAAM,IAAA,CAAK,iBAAkB,CAAA,UAAA;AAAA,UAC1C,MAAA,CAAO,IAAI,CAAU,KAAA,MAAA;AAAA,YACjB,mBAAmB,KAAM,CAAA,iBAAA;AAAA,YACzB,QAAQ,IAAK,CAAA,MAAA;AAAA,YACb,WAAa,EAAA;AAAA,cACT,IAAI,KAAM,CAAA,EAAA;AAAA,cACV,UAAU,KAAM,CAAA,GAAA;AAAA,cAChB,UAAU,KAAM,CAAA,SAAA;AAAA,cAChB,OAAO,KAAM,CAAA,KAAA;AAAA,cACb,MAAM,KAAM,CAAA;AAAA;AAChB,WACF,CAAA,CAAA;AAAA,UACF,WAAc,GAAA;AAAA,SAClB;AAEA,QAAA,IAAI,WAAW,QAAU,EAAA;AACrB,UAAA,MAAM,IAAI,KAAA,CAAM,QAAS,CAAA,KAAA,CAAM,OAAO,CAAA;AAAA;AAG1C,QAAO,OAAA,QAAA;AAAA,eACF,KAAO,EAAA;AACZ,QAAA,OAAA,CAAQ,KAAM,CAAA,CAAA,yBAAA,EAA4B,CAAI,GAAA,CAAC,YAAY,KAAK,CAAA;AAChE,QAAA,IAAI,CAAM,KAAA,IAAA,CAAK,WAAc,GAAA,CAAA,EAAS,MAAA,KAAA;AACtC,QAAA,MAAM,IAAI,OAAQ,CAAA,CAAA,CAAA,KAAK,WAAW,CAAG,EAAA,IAAA,CAAK,WAAW,CAAC,CAAA;AAAA;AAC1D;AAEJ,IAAO,OAAA,IAAA;AAAA;AACX,EAEA,MAAc,kBAAkB,QAAwC,EAAA;AACpE,IAAA,MAAM,KAAK,MAAM,IAAA,CAAK,MAAO,CAAA,QAAA,CAAS,eAAe,QAAQ,CAAA;AAC7D,IAAI,IAAA,CAAC,IAAI,EAAM,IAAA,CAAC,IAAI,QAAY,IAAA,CAAC,IAAI,KAAO,EAAA;AACxC,MAAM,MAAA,IAAI,MAAM,qBAAqB,CAAA;AAAA;AAGzC,IAAO,OAAA;AAAA,MACH,IAAI,EAAG,CAAA,EAAA;AAAA,MACP,GAAA,EAAK,EAAG,CAAA,QAAA,CAAS,QAAS,EAAA;AAAA,MAC1B,SAAA,EAAW,EAAG,CAAA,QAAA,CAAS,QAAS,EAAA;AAAA,MAChC,KAAA,EAAO,EAAG,CAAA,KAAA,CAAM,QAAS,EAAA;AAAA,MACzB,OAAO,EAAG,CAAA,IAAA;AAAA,MACV,IAAA,EAAM,KAAK,MAAO,CAAA,OAAA;AAAA,MAClB,iBAAmB,EAAA,QAAA;AAAA,MACnB,MAAA,EAAQ,KAAK,MAAO,CAAA;AAAA,KACxB;AAAA;AACJ,EAEA,MAAc,cAAe,CAAA,MAAA,EAAuB,WAAoC,EAAA;AACpF,IAAA,MAAM,YAAe,GAAA,MAAA,CAAO,GAAI,CAAA,CAAA,KAAA,KAAS,MAAM,iBAAiB,CAAA;AAChE,IAAA,MAAM,aAAa,MAAM,IAAA,CAAK,iBAAkB,CAAA,QAAA,CAAS,cAAc,WAAW,CAAA;AAElF,IAAA,IAAI,WAAW,UAAY,EAAA;AACvB,MAAA,MAAM,IAAI,KAAM,CAAA,CAAA,mBAAA,EAAsB,UAAW,CAAA,KAAA,CAAM,OAAO,CAAE,CAAA,CAAA;AAAA;AAIpE,IAAA,MAAM,EAAE,cAAA,EAAgB,YAAc,EAAA,YAAA,EAAiB,GAAA,UAAA;AACvD,IAAM,MAAA,IAAA,GAAO,cAAe,CAAA,GAAA,CAAI,YAAY,CAAA;AAC5C,IAAM,MAAA,MAAA,GAAS,YAAa,CAAA,GAAA,CAAI,IAAI,CAAA;AAEpC,IAAA,IAAI,MAAO,CAAA,GAAA,CAAI,IAAK,CAAA,UAAA,CAAW,kBAAkB,CAAG,EAAA;AAChD,MAAM,MAAA,IAAI,MAAM,8BAA8B,CAAA;AAAA;AAClD;AACJ,EAEA,MAAM,gCAAA,CAAiC,MAAuB,EAAA,WAAA,EAAqB,SAA+B,EAAA;AAC9G,IAAY,WAAA,CAAA,GAAA,CAAI,CAAuD,oDAAA,EAAA,WAAW,CAAE,CAAA,CAAA;AAEpF,IAAI,IAAA;AAEA,MAAM,MAAA,EAAE,iBAAiB,WAAY,EAAA,GAAI,MAAM,eAAgB,CAAA,IAAA,CAAK,OAAO,QAAoB,CAAA;AAG/F,MAAM,MAAA,yBAAA,GAA4B,MAAM,gCAAA,CAAiC,SAAS,CAAA;AAClF,MAAI,IAAA,uBAAA,GAA0BA,WAAU,CAAA,IAAA,CAAK,CAAC,CAAA;AAG9C,MAAA,KAAA,MAAW,SAAS,yBAA2B,EAAA;AAC3C,QAAM,MAAA,YAAA,GAAeA,WAAU,CAAA,IAAA,CAAK,KAAK,CAAA;AACzC,QAAI,IAAA,YAAA,CAAa,EAAG,CAAA,uBAAuB,CAAG,EAAA;AAC1C,UAA0B,uBAAA,GAAA,YAAA;AAAA;AAC9B;AAIJ,MAAM,MAAA,gBAAA,GAAmB,MAAM,IAAK,CAAA,4BAAA;AAAA,QAChC,eAAA;AAAA,QACA,WAAA;AAAA,QACA;AAAA,OACJ;AAGA,MAAI,IAAA,gBAAA,CAAiB,GAAI,CAAA,eAAe,CAAG,EAAA;AACvC,QAAM,MAAA,IAAI,MAAM,uCAAuC,CAAA;AAAA;AAI3D,MAAM,MAAA,gBAAA,GAAmB,MAAM,cAAA,CAAe,gBAAgB,CAAA;AAC9D,MAAA,IAAI,CAAC,gBAAkB,EAAA;AACnB,QAAM,MAAA,IAAI,MAAM,oBAAoB,CAAA;AAAA;AAIxC,MAAA,MAAM,mBAAmB,IAAK,CAAA,KAAA,CAAM,IAAK,CAAA,GAAA,KAAQ,GAAI,CAAA;AACrD,MAAA,MAAM,eAAe,gBAAmB,GAAA,EAAA;AAGxC,MAAA,MAAM,oBAAoB,WAAc,GAAA,CAAA;AACxC,MAAM,MAAA,gBAAA,GAAmB,MAAM,IAAA,CAAK,iBAAkB,CAAA,UAAA;AAAA,QAClD,MAAA,CAAO,IAAI,CAAU,KAAA,MAAA;AAAA,UACjB,mBAAmB,KAAM,CAAA,iBAAA;AAAA,UACzB,QAAQ,IAAK,CAAA,MAAA;AAAA,UACb,WAAa,EAAA;AAAA,YACT,IAAI,KAAM,CAAA,EAAA;AAAA,YACV,UAAU,KAAM,CAAA,GAAA;AAAA,YAChB,UAAU,KAAM,CAAA,SAAA;AAAA,YAChB,OAAO,KAAM,CAAA,KAAA;AAAA,YACb,MAAM,KAAM,CAAA;AAAA;AAChB,SACF,CAAA,CAAA;AAAA,QACF,iBAAA;AAAA,QACA;AAAA,UACI,YAAc,EAAA,gBAAA;AAAA,UACd;AAAA;AACJ,OACJ;AAGA,MAAA,IAAI,WAAW,gBAAkB,EAAA;AAC7B,QAAA,MAAM,IAAI,KAAM,CAAA,CAAA,0BAAA,EAA6B,gBAAiB,CAAA,KAAA,CAAM,OAAO,CAAE,CAAA,CAAA;AAAA;AAGjF,MAAA,WAAA,CAAY,IAAI,gCAAkC,EAAA;AAAA,QAC9C,WAAa,EAAA,iBAAA;AAAA,QACb,gBAAA,EAAkB,iBAAiB,QAAS,EAAA;AAAA,QAC5C,YAAY,gBAAiB,CAAA;AAAA,OAChC,CAAA;AAAA,aAEI,KAAO,EAAA;AACZ,MAAQ,OAAA,CAAA,KAAA,CAAM,oDAAoD,KAAK,CAAA;AACvE,MAAM,MAAA,KAAA;AAAA;AACV;AACJ,EAEA,MAAc,4BAAA,CACV,eACA,EAAA,WAAA,EACA,uBACkB,EAAA;AAClB,IAAA,WAAA,CAAY,IAAI,gCAAkC,EAAA;AAAA,MAC9C,OAAA,EAAS,gBAAgB,QAAS,EAAA;AAAA,MAClC,OAAA,EAAS,YAAY,QAAS,EAAA;AAAA,MAC9B,SAAA,EAAW,wBAAwB,QAAS;AAAA,KAC/C,CAAA;AAGD,IAAA,IAAI,gBAAmB,GAAA,eAAA;AACvB,IAAI,IAAA,WAAA,CAAY,EAAG,CAAA,gBAAgB,CAAG,EAAA;AAClC,MAAmB,gBAAA,GAAA,WAAA;AAAA;AAEvB,IAAI,IAAA,uBAAA,CAAwB,EAAG,CAAA,gBAAgB,CAAG,EAAA;AAC9C,MAAmB,gBAAA,GAAA,uBAAA;AAAA;AAIvB,IAAA,MAAM,UAAU,gBAAiB,CAAA,GAAA,CAAI,EAAE,CAAA,CAAE,IAAI,GAAG,CAAA;AAChD,IAAmB,gBAAA,GAAA,gBAAA,CAAiB,IAAI,OAAO,CAAA;AAE/C,IAAA,WAAA,CAAY,GAAI,CAAA,qBAAA,EAAuB,gBAAiB,CAAA,QAAA,EAAU,CAAA;AAClE,IAAO,OAAA,gBAAA;AAAA;AACX,EAEA,MAAc,sBAAA,CACV,aACA,EAAA,YAAA,EACA,cACA,MACkB,EAAA;AAClB,IAAA,WAAA,CAAY,IAAI,iCAAiC,CAAA;AAGjD,IAAA,MAAM,qBAAwB,GAAA,MAAM,aAAc,CAAA,WAAA,CAAY,YAAY,CAAA;AAC1E,IAAA,MAAM,sBAAyB,GAAA,MAAM,YAAa,CAAA,WAAA,CAAY,YAAY,CAAA;AAG1E,IAAM,MAAA,YAAA,GAAeA,WAAU,CAAA,IAAA,CAAK,GAAM,CAAA;AAG1C,IAAA,MAAM,cAAiB,GAAA,MAAM,aAAc,CAAA,cAAA,CAAe,cAAc,YAAY,CAAA;AACpF,IAAA,MAAM,eAAkB,GAAA,MAAM,YAAa,CAAA,cAAA,CAAe,cAAc,YAAY,CAAA;AAEpF,IAAA,MAAM,aAAgB,GAAA,MAAM,aAAc,CAAA,aAAA,CAAc,YAAY,CAAA;AACpE,IAAA,MAAM,cAAiB,GAAA,MAAM,YAAa,CAAA,aAAA,CAAc,YAAY,CAAA;AAGpE,IAAI,IAAA,IAAA,GAAOA,WAAU,CAAA,IAAA,CAAK,CAAC,CAAA;AAC3B,IAAA,IAAI,KAAQ,GAAA,YAAA;AACZ,IAAI,IAAA,aAAA,GAAgBA,WAAU,CAAA,IAAA,CAAK,CAAC,CAAA;AACpC,IAAI,IAAA,iBAAA,GAAoBA,WAAU,CAAA,IAAA,CAAK,CAAC,CAAA;AAExC,IAAO,OAAA,IAAA,CAAK,EAAG,CAAA,KAAK,CAAG,EAAA;AACnB,MAAA,MAAM,MAAM,IAAK,CAAA,GAAA,CAAI,KAAK,CAAA,CAAE,IAAI,CAAC,CAAA;AAGjC,MAAM,MAAA,cAAA,GAAiB,MAClB,CAAA,GAAA,CAAI,GAAG,CAAA,CACP,GAAI,CAAA,cAAA,CAAe,GAAI,CAAA,GAAG,CAAC,CAAA,CAC3B,GAAI,CAAA,eAAA,CAAgB,GAAI,CAAA,GAAG,CAAC,CAAA,CAC5B,GAAI,CAAA,aAAA,CAAc,GAAI,CAAA,GAAG,CAAC,CAAA,CAC1B,GAAI,CAAA,cAAA,CAAe,GAAI,CAAA,GAAG,CAAC,CAAA;AAEhC,MAAI,IAAA,cAAA,CAAe,GAAG,iBAAiB,CAAA,IAAK,eAAe,GAAI,CAAA,IAAA,CAAK,UAAW,CAAA,kBAAkB,CAAG,EAAA;AAChG,QAAoB,iBAAA,GAAA,cAAA;AACpB,QAAgB,aAAA,GAAA,GAAA;AAChB,QAAO,IAAA,GAAA,GAAA,CAAI,IAAI,CAAC,CAAA;AAAA,OACb,MAAA;AACH,QAAQ,KAAA,GAAA,GAAA,CAAI,IAAI,CAAC,CAAA;AAAA;AACrB;AAIJ,IAAgBA,aAAAA,GAAAA,WAAAA,CAAU,KAAK,IAAK,CAAA,GAAA;AAAA,MAChC,cAAc,QAAS,EAAA;AAAA,MACvB,sBAAsB,QAAS,EAAA;AAAA,MAC/B,uBAAuB,QAAS;AAAA,KACnC,CAAA;AAED,IAAY,WAAA,CAAA,GAAA,CAAI,CAA2C,wCAAA,EAAA,aAAa,CAAE,CAAA,CAAA;AAC1E,IAAO,OAAA,aAAA;AAAA;AAEf,CAAA;AAGA,eAAe,eAAe,SAAwC,EAAA;AAClE,EAAM,MAAA,OAAA,GAAU,SAAU,CAAA,GAAA,CAAI,IAAK,CAAA;AACnC,EAAA,WAAA,CAAY,GAAI,CAAA,CAAA,4BAAA,EAA+B,SAAS,CAAA,YAAA,EAAe,OAAO,CAAE,CAAA,CAAA;AAChF,EAAO,OAAA,OAAA;AACX;AAEA,eAAsB,iCAAiC,SAAuE,EAAA;AAC1H,EAAA,WAAA,CAAY,IAAI,2CAA2C,CAAA;AAC3D,EAAM,MAAA,YAAA,GAAe,MAAM,SAAA,CAAU,eAAgB,EAAA;AACrD,EAAA,MAAM,4BAA4B,YAAa,CAAA,GAAA,CAAI,CAAC,KAAA,KAAoC,MAAM,cAAc,CAAA;AAC5G,EAAY,WAAA,CAAA,GAAA,CAAI,CAAiE,8DAAA,EAAA,yBAAyB,CAAE,CAAA,CAAA;AAC5G,EAAO,OAAA,yBAAA;AACX;AAEA,eAAsB,gBAAgB,QAGnC,EAAA;AACC,EAAM,MAAA,OAAA,GAAU,MAAM,QAAA,CAAS,UAAW,EAAA;AAC1C,EAAA,MAAM,eAAkB,GAAA,OAAA,CAAQ,QAAYA,IAAAA,WAAAA,CAAU,KAAK,CAAC,CAAA;AAG5D,EAAA,MAAM,KAAQ,GAAA,MAAM,QAAS,CAAA,QAAA,CAAS,QAAQ,CAAA;AAC9C,EAAA,MAAM,SAAsB,EAAC;AAC7B,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,CAAA,EAAG,CAAK,EAAA,EAAA;AACxB,IAAA,MAAM,kBAAkB,MAAM,QAAA,CAAS,QAAS,CAAA,KAAA,CAAM,SAAS,CAAC,CAAA;AAChE,IAAA,IAAI,gBAAgB,aAAe,EAAA;AAC/B,MAAO,MAAA,CAAA,IAAA,CAAK,gBAAgB,aAAa,CAAA;AAAA;AAC7C;AAGJ,EAAA,MAAM,cAAc,MAAO,CAAA,MAAA,GAAS,CAC9B,GAAA,MAAA,CAAO,OAAO,CAAC,CAAA,EAAG,CAAM,KAAA,CAAA,CAAE,IAAI,CAAC,CAAC,EAAE,GAAI,CAAA,MAAA,CAAO,MAAM,CACnD,GAAA,eAAA;AAEN,EAAO,OAAA,EAAE,iBAAiB,WAAY,EAAA;AAC1C;AC1fO,IAAM,gBAAA,GAAN,cAA+B,OAAQ,CAAA;AAAA,EAAvC,WAAA,GAAA;AAAA,IAAA,KAAA,CAAA,GAAA,SAAA,CAAA;AACH,IAAA,IAAA,CAAQ,SAA8B,GAAA,IAAA;AACtC,IAAA,IAAA,CAAQ,YAAiC,GAAA,IAAA;AACzC,IAAA,IAAA,CAAQ,iBAAiB,EAAC;AAC1B,IAAA,IAAA,CAAQ,YAAe,GAAA,CAAA;AAAA;AAAA,EAGvB,WAAW,WAA2B,GAAA;AAClC,IAAA,OAAOD,WAAY,CAAA,SAAA;AAAA;AACvB,EAEA,IAAI,WAA2B,GAAA;AAC3B,IAAA,OAAOA,WAAY,CAAA,SAAA;AAAA;AACvB;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,WAAW,OAAuC,EAAA;AACpD,IAAA,IAAA,CAAK,OAAU,GAAA,OAAA;AAGf,IAAI,IAAA,KAAA,GAAQ,OAAQ,CAAA,UAAA,CAAW,2BAA2B,CAAA;AAE1D,IAAI,IAAA,MAAA,GAAS,OAAQ,CAAA,UAAA,CAAW,4BAA4B,CAAA;AAI5D,IAAA,OAAA,CAAQ,IAAI,qCAAuC,EAAA;AAAA,MAC/C,KAAA;AAAA,MACA;AAAA,KACH,CAAA;AAED,IAAI,IAAA,CAAC,KAAS,IAAA,CAAC,MAAQ,EAAA;AACnB,MAAM,MAAA,IAAI,MAAM,4EAA4E,CAAA;AAAA;AAIhG,IAAI,IAAA,CAAC,SAAS,MAAQ,EAAA;AAClB,MAAQ,KAAA,GAAA,MAAA,CAAO,OAAQ,CAAA,UAAA,EAAY,QAAQ,CAAA;AAC3C,MAAQ,OAAA,CAAA,GAAA,CAAI,gCAAgC,KAAK,CAAA;AAAA;AAGrD,IAAA,IAAI,CAAC,KAAO,EAAA;AACR,MAAM,MAAA,IAAI,MAAM,gDAAgD,CAAA;AAAA;AAIpE,IAAM,MAAA,SAAA,GAAY,OAAQ,CAAA,UAAA,CAAW,2BAA2B,CAAA;AAChE,IAAA,IAAI,CAAC,SAAA,EAAiB,MAAA,IAAI,MAAM,uCAAuC,CAAA;AAGvE,IAAQ,OAAA,CAAA,GAAA,CAAI,4CAA4C,KAAK,CAAA;AAC7D,IAAM,MAAA,QAAA,GAAW,IAAI,iBAAA,CAAkB,KAAe,CAAA;AACtD,IAAA,MAAM,MAAS,GAAA,IAAIE,MAAO,CAAA,SAAA,EAAW,QAAQ,CAAA;AAG7C,IAAM,MAAA,YAAA,GAAe,OAAQ,CAAA,UAAA,CAAW,6BAA6B,CAAA;AACrE,IAAA,IAAI,CAAC,YAAA,EAAoB,MAAA,IAAI,MAAM,yCAAyC,CAAA;AAE5E,IAAM,MAAA,iBAAA,GAAoB,MAAM,uBAAwB,CAAA,MAAA;AAAA,MACpD,QAAA;AAAA,MACA,MAAA;AAAA,MACA;AAAA,KACJ;AAGA,IAAM,MAAA,qBAAA,GAAwB,OAAQ,CAAA,UAAA,CAAW,yBAAyB,CAAA;AAC1E,IAAA,IAAI,CAAC,qBAAA,EAA6B,MAAA,IAAI,MAAM,qCAAqC,CAAA;AAGjF,IAAA,MAAM,yBAAyB,IAAI,QAAA;AAAA,MAC/B,qBAAA;AAAA,MACA;AAAA,QACI,2DAAA;AAAA,QACA;AAAA,OACJ;AAAA,MACA;AAAA,KACJ;AAGA,IAAA,IAAA,CAAK,YAAY,IAAI,SAAA;AAAA,MACjB,MAAA;AAAA,MACA,iBAAA;AAAA,MACA;AAAA,KACJ;AAGA,IAAQ,OAAA,CAAA,GAAA,CAAI,uCAAuC,KAAK,CAAA;AACxD,IAAK,IAAA,CAAA,YAAA,GAAe,IAAI,SAAA,CAAU,KAAK,CAAA;AACvC,IAAA,IAAA,CAAK,sBAAuB,EAAA;AAAA;AAChC,EAEQ,sBAA+B,GAAA;AACnC,IAAI,IAAA,CAAC,KAAK,YAAc,EAAA;AAExB,IAAK,IAAA,CAAA,YAAA,CAAa,EAAG,CAAA,MAAA,EAAQ,MAAM;AAC/B,MAAA,OAAA,CAAQ,IAAI,kCAAkC,CAAA;AAE9C,MAAK,IAAA,CAAA,YAAA,EAAc,IAAK,CAAA,IAAA,CAAK,SAAU,CAAA;AAAA,QACnC,OAAS,EAAA,KAAA;AAAA,QACT,EAAI,EAAA,CAAA;AAAA,QACJ,MAAQ,EAAA,eAAA;AAAA,QACR,MAAA,EAAQ,CAAC,UAAU;AAAA,OACtB,CAAC,CAAA;AAAA,KACL,CAAA;AAED,IAAA,IAAA,CAAK,YAAa,CAAA,EAAA,CAAG,SAAW,EAAA,OAAO,IAAiB,KAAA;AACpD,MAAM,MAAA,OAAA,GAAU,IAAK,CAAA,KAAA,CAAM,IAAI,CAAA;AAC/B,MAAI,IAAA,OAAA,CAAQ,MAAQ,EAAA,MAAA,EAAQ,MAAQ,EAAA;AAChC,QAAA,IAAA,CAAK,eAAe,MAAO,CAAA,QAAA,CAAS,QAAQ,MAAO,CAAA,MAAA,CAAO,QAAQ,EAAE,CAAA;AAAA;AACxE,KACH,CAAA;AAED,IAAA,IAAA,CAAK,YAAa,CAAA,EAAA,CAAG,OAAS,EAAA,CAAC,KAAU,KAAA;AACrC,MAAQ,OAAA,CAAA,KAAA,CAAM,oBAAoB,KAAK,CAAA;AAAA,KAC1C,CAAA;AAED,IAAK,IAAA,CAAA,YAAA,CAAa,EAAG,CAAA,OAAA,EAAS,MAAM;AAChC,MAAA,OAAA,CAAQ,IAAI,6BAA6B,CAAA;AAEzC,MAAA,UAAA,CAAW,MAAM,IAAK,CAAA,UAAA,CAAW,IAAK,CAAA,OAAO,GAAG,GAAI,CAAA;AAAA,KACvD,CAAA;AAAA;AACL,EAEA,MAAM,eAAmD,GAAA;AACrD,IAAA,IAAI,CAAC,IAAK,CAAA,SAAA,EAAiB,MAAA,IAAI,MAAM,kCAAkC,CAAA;AACvE,IAAA,OAAO,IAAK,CAAA,SAAA,CAAU,eAAgB,CAAA,IAAA,CAAK,cAAc,CAAA;AAAA;AAC7D,EAEA,MAAM,iBAAiB,OAAgD,EAAA;AACnE,IAAA,IAAI,CAAC,IAAK,CAAA,SAAA,EAAiB,MAAA,IAAI,MAAM,kCAAkC,CAAA;AACvE,IAAA,MAAM,WAAc,GAAA,EAAA;AACpB,IAAA,OAAO,KAAK,SAAU,CAAA,kBAAA,CAAmB,OAAS,EAAA,IAAA,CAAK,cAAc,WAAW,CAAA;AAAA;AACpF,EAEA,MAAM,IAAsB,GAAA;AACxB,IAAA,IAAI,KAAK,YAAc,EAAA;AACnB,MAAA,IAAA,CAAK,aAAa,KAAM,EAAA;AACxB,MAAA,IAAA,CAAK,YAAe,GAAA,IAAA;AAAA;AACxB;AAER,CAAA;;;AC9JA,IAAM,gBAAA,GAAmB,IAAI,gBAAiB,EAAA;AAE9C,IAAM,eAA0B,GAAA;AAAA,EAC5B,IAAM,EAAA,kBAAA;AAAA,EACN,WAAa,EAAA,oCAAA;AAAA,EACb,OAAA,EAAS,CAAC,sBAAsB,CAAA;AAAA,EAChC,SAAA,EAAW,CAAC,cAAc,CAAA;AAAA,EAC1B,QAAA,EAAU,CAAC,gBAAgB;AAC/B,CAAA;AAEA,IAAO,aAAQ,GAAA","file":"index.mjs","sourcesContent":["import { Action, IAgentRuntime, Memory, ServiceType } from \"@elizaos/core\";\nimport { ArbitrageService } from \"../services/ArbitrageService\";\n\nexport const executeArbitrageAction: Action = {\n    name: \"EXECUTE_ARBITRAGE\",\n    similes: [\"TRADE_ARBITRAGE\", \"RUN_ARBITRAGE\"],\n    description: \"Execute arbitrage trades across markets\",\n\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\n        // Validate settings are present\n        return runtime.getSetting(\"arbitrage.walletPrivateKey\") !== undefined;\n    },\n\n    handler: async (runtime: IAgentRuntime, _message: Memory) => {\n        const service = runtime.getService(ServiceType.ARBITRAGE) as ArbitrageService;\n        const markets = await service.evaluateMarkets();\n\n        if (markets.length > 0) {\n            await service.executeArbitrage(markets);\n        }\n\n        return true;\n    },\n\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: { text: \"Find arbitrage opportunities\" }\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Scanning for arbitrage trades\",\n                    action: \"EXECUTE_ARBITRAGE\"\n                }\n            }\n        ]\n    ]\n};","import { Provider, IAgentRuntime, Memory, ServiceType } from \"@elizaos/core\";\nimport { ArbitrageService } from \"../services/ArbitrageService\";\nimport { ArbitrageState } from \"../type\";\n\nexport const marketProvider: Provider = {\n    get: async (runtime: IAgentRuntime, _message: Memory): Promise<ArbitrageState> => {\n        const service = runtime.getService(ServiceType.ARBITRAGE) as ArbitrageService;\n        const markets = await service.evaluateMarkets();\n\n        return {\n            opportunities: markets.length,\n            totalProfit: \"0\", // Calculate total profit\n            lastUpdate: new Date().toISOString(),\n            markets: {}  // This will be populated by the service\n        };\n    }\n};","import { BigNumber } from \"ethers\";\n\nexport interface MarketThresholds {\n    minProfitThreshold: BigNumber;\n    maxTradeSize: BigNumber;\n    gasLimit: number;\n    minerRewardPercentage: number;\n}\n\nexport const DEFAULT_THRESHOLDS: MarketThresholds = {\n    minProfitThreshold: BigNumber.from(\"100000000000000\"), // 0.0001 ETH\n    maxTradeSize: BigNumber.from(\"1000000000000000000\"), // 1 ETH\n    gasLimit: 500000,\n    minerRewardPercentage: 90\n};","export const WETH_ADDRESS = \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\";\n\n// Uniswap V2 Factory addresses for major DEXes\nexport const FACTORY_ADDRESSES = {\n    UNISWAP: \"0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\",\n    SUSHISWAP: \"0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac\",\n    SHIBASWAP: \"0x115934131916C8b277DD010Ee02de363c09d037c\"\n};\n\n// Uniswap lookup contract for price checks\nexport const UNISWAP_LOOKUP_CONTRACT_ADDRESS = \"0x5EF1009b9FCD4fec3094a5564047e190D72Bd511\";","import { BigNumber, Wallet } from \"ethers\";\n\n// Constants\nexport const ETHER = BigNumber.from(10).pow(18);\nexport const DEFAULT_GAS_LIMIT = 250000;\n\n// Math utilities\nexport function bigNumberToDecimal(value: BigNumber, base = 18): number {\n    const divisor = BigNumber.from(10).pow(base);\n    return value.mul(10000).div(divisor).toNumber() / 10000;\n}\n\n// Authentication utilities\nexport const getDefaultRelaySigningKey = (): string => {\n    console.warn(\n        \"No FLASHBOTS_RELAY_SIGNING_KEY specified. Creating temporary key...\"\n    );\n    return Wallet.createRandom().privateKey;\n};\n\n// Add error handling utilities\nexport const handleArbitrageError = (error: Error): void => {\n    console.error(`Arbitrage Error: ${error.message}`);\n    // Add any specific error handling logic\n};","import { BigNumber } from \"@ethersproject/bignumber\";\nimport { Contract } from \"@ethersproject/contracts\";\nimport { Provider, TransactionResponse } from \"@ethersproject/providers\";\nimport { Wallet } from \"@ethersproject/wallet\";\nimport { FlashbotsBundleProvider } from \"@flashbots/ethers-provider-bundle\";\nimport { DEFAULT_THRESHOLDS, MarketThresholds } from '../config/thresholds';\nimport { WETH_ADDRESS } from \"./addresses\";\nimport { EthMarket } from \"./EthMarket\";\nimport { CrossedMarketDetails, MarketsByToken, MarketType } from \"./types\";\nimport { ETHER } from \"./utils\";\nimport { elizaLogger } from \"@elizaos/core\";\n\nexport interface BundleEntry {\n  to: string;\n  gas: number;\n  gas_price: string;\n  value: number;\n  input: string;\n  from: string;\n  signedTransaction: string;\n  signer: string;\n}\n\nexport class Arbitrage {\n    private bundleEntries: { bundle: BundleEntry[], blockNumber: number }[] = [];\n    private thresholds: MarketThresholds = DEFAULT_THRESHOLDS;\n    private MAX_RETRIES = 3;\n    private RETRY_DELAY = 1000; // 1 second\n\n    constructor(\n        private wallet: Wallet,\n        private flashbotsProvider: FlashbotsBundleProvider,\n        private bundleExecutorContract: Contract\n    ) {}\n\n    async evaluateMarkets(marketsByToken: MarketsByToken): Promise<CrossedMarketDetails[]> {\n        elizaLogger.log(\"Starting market evaluation...\");\n        const opportunities: CrossedMarketDetails[] = [];\n\n        for (const [tokenAddress, markets] of Object.entries(marketsByToken)) {\n            // Filter out markets with insufficient liquidity\n            const validMarkets = await this.filterValidMarkets(markets, tokenAddress);\n            \n            // Compare each market pair for arbitrage opportunities\n            for (let i = 0; i < validMarkets.length; i++) {\n                for (let j = i + 1; j < validMarkets.length; j++) {\n                    const opportunity = await this.checkArbitrageOpportunity(\n                        validMarkets[i],\n                        validMarkets[j],\n                        tokenAddress\n                    );\n                    if (opportunity) {\n                        opportunities.push(opportunity);\n                    }\n                }\n            }\n        }\n\n        // Sort opportunities by profit\n        return opportunities.sort((a, b) => b.profit.sub(a.profit).toNumber());\n    }\n\n    private async filterValidMarkets(markets: EthMarket[], tokenAddress: string): Promise<EthMarket[]> {\n        const validMarkets: EthMarket[] = [];\n        for (const market of markets) {\n            try {\n                const reserves = await market.getReserves(tokenAddress);\n                if (reserves.gt(this.thresholds.minProfitThreshold)) {\n                    validMarkets.push(market);\n                }\n            } catch (error) {\n                console.error(`Error checking market ${market.marketAddress}:`, error);\n            }\n        }\n        return validMarkets;\n    }\n\n    private async checkArbitrageOpportunity(\n        market1: EthMarket,\n        market2: EthMarket,\n        tokenAddress: string\n    ): Promise<CrossedMarketDetails | null> {\n        try {\n            // Get prices from both markets\n            const price1 = await market1.getTokensOut(WETH_ADDRESS, tokenAddress, ETHER);\n            const price2 = await market2.getTokensOut(WETH_ADDRESS, tokenAddress, ETHER);\n\n            // Calculate potential profit\n            const [buyMarket, sellMarket] = price1.gt(price2) \n                ? [market2, market1] \n                : [market1, market2];\n            \n            const profit = price1.gt(price2) \n                ? price1.sub(price2) \n                : price2.sub(price1);\n\n            if (profit.gt(this.thresholds.minProfitThreshold)) {\n                // Calculate optimal trade volume\n                const volume = await this.calculateOptimalVolume(buyMarket, sellMarket, tokenAddress, profit);\n                \n                return {\n                    marketPairs: [{\n                        buyFromMarket: buyMarket,\n                        sellToMarket: sellMarket\n                    }],\n                    profit,\n                    volume,\n                    tokenAddress,\n                    buyFromMarket: buyMarket,\n                    sellToMarket: sellMarket\n                };\n            }\n        } catch (error) {\n            console.error(\"Error checking arbitrage opportunity:\", error);\n        }\n        return null;\n    }\n\n    async takeCrossedMarkets(\n        markets: CrossedMarketDetails[], \n        currentBlock: number, \n        maxAttempts: number\n    ): Promise<void> {\n        for (const market of markets) {\n            for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n                try {\n                    const transaction = await this.executeArbitrageTrade(market, currentBlock);\n                    if (transaction) {\n                        elizaLogger.log(`Successful arbitrage execution: ${transaction.hash}`);\n                        // Wait for confirmation\n                        await transaction.wait(1);\n                        break;\n                    }\n                } catch (error) {\n                    console.error(`Attempt ${attempt} failed:`, error);\n                    if (attempt === maxAttempts) {\n                        console.error(\"Max attempts reached for market\", market);\n                    } else {\n                        await new Promise(r => setTimeout(r, this.RETRY_DELAY));\n                    }\n                }\n            }\n        }\n    }\n\n    private async executeArbitrageTrade(\n        market: CrossedMarketDetails,\n        blockNumber: number\n    ): Promise<TransactionResponse | null> {\n        // Prepare the trade calls\n        const buyCalls = await market.buyFromMarket.sellTokensToNextMarket(\n            WETH_ADDRESS,\n            market.volume,\n            market.sellToMarket\n        );\n\n        // Calculate intermediate amounts\n        const intermediateAmount = await market.buyFromMarket.getTokensOut(\n            WETH_ADDRESS,\n            market.tokenAddress,\n            market.volume\n        );\n\n        // Prepare sell call\n        const sellCallData = await market.sellToMarket.sellTokens(\n            market.tokenAddress,\n            intermediateAmount,\n            this.bundleExecutorContract.address\n        );\n\n        // Combine all calls\n        const targets = [...buyCalls.targets, market.sellToMarket.marketAddress];\n        const payloads = [...buyCalls.data, sellCallData];\n\n        // Calculate miner reward (90% of profit)\n        const minerReward = market.profit.mul(90).div(100);\n\n        // Create and simulate bundle\n        const bundle = await this.createBundle(\n            market.volume,\n            minerReward,\n            targets,\n            payloads,\n            blockNumber\n        );\n\n        // Execute if simulation successful\n        return this.executeBundleWithRetry(bundle, blockNumber);\n    }\n\n    private async createBundle(\n        volume: BigNumber,\n        minerReward: BigNumber,\n        targets: string[],\n        payloads: string[],\n        blockNumber: number\n    ): Promise<BundleEntry[]> {\n        // Estimate gas\n        const gasEstimate = await this.estimateGasWithBuffer(\n            volume,\n            minerReward,\n            targets,\n            payloads\n        );\n\n        // Get optimal gas price\n        const gasPrice = await this.getOptimalGasPrice(blockNumber);\n\n        // Create transaction\n        const transaction = await this.bundleExecutorContract.populateTransaction.uniswapWeth(\n            volume,\n            minerReward,\n            targets,\n            payloads,\n            { gasLimit: gasEstimate, gasPrice }\n        );\n\n        // Sign transaction\n        const signedTx = await this.wallet.signTransaction(transaction);\n        \n        // Create bundle entry\n        const bundleEntry = await this.createBundleEntry(signedTx);\n        \n        return [bundleEntry];\n    }\n\n    private async estimateGasWithBuffer(\n        volume: BigNumber,\n        minerReward: BigNumber,\n        targets: string[],\n        payloads: string[]\n    ): Promise<BigNumber> {\n        const estimate = await this.bundleExecutorContract.estimateGas.uniswapWeth(\n            volume,\n            minerReward,\n            targets,\n            payloads\n        );\n        return estimate.mul(120).div(100); // Add 20% buffer\n    }\n\n    private async getOptimalGasPrice(blockNumber: number): Promise<BigNumber> {\n        const { currentGasPrice, avgGasPrice } = await getGasPriceInfo(this.wallet.provider as Provider);\n        const basePrice = currentGasPrice.gt(avgGasPrice) ? currentGasPrice : avgGasPrice;\n        return basePrice.mul(110).div(100); // Add 10% to be competitive\n    }\n\n    private async executeBundleWithRetry(\n        bundle: BundleEntry[], \n        blockNumber: number\n    ): Promise<TransactionResponse | null> {\n        for (let i = 0; i < this.MAX_RETRIES; i++) {\n            try {\n                // Simulate first\n                await this.simulateBundle(bundle, blockNumber);\n                \n                // If simulation successful, submit\n                const response = await this.flashbotsProvider.sendBundle(\n                    bundle.map(entry => ({\n                        signedTransaction: entry.signedTransaction,\n                        signer: this.wallet,\n                        transaction: {\n                            to: entry.to,\n                            gasLimit: entry.gas,\n                            gasPrice: entry.gas_price,\n                            value: entry.value,\n                            data: entry.input\n                        }\n                    })),\n                    blockNumber + 1\n                );\n\n                if ('error' in response) {\n                    throw new Error(response.error.message);\n                }\n\n                return response as unknown as TransactionResponse;\n            } catch (error) {\n                console.error(`Bundle execution attempt ${i + 1} failed:`, error);\n                if (i === this.MAX_RETRIES - 1) throw error;\n                await new Promise(r => setTimeout(r, this.RETRY_DELAY));\n            }\n        }\n        return null;\n    }\n\n    private async createBundleEntry(signedTx: string): Promise<BundleEntry> {\n        const tx = await this.wallet.provider.getTransaction(signedTx);\n        if (!tx?.to || !tx?.gasPrice || !tx?.value) {\n            throw new Error(\"Invalid transaction\");\n        }\n\n        return {\n            to: tx.to,\n            gas: tx.gasLimit.toNumber(),\n            gas_price: tx.gasPrice.toString(),\n            value: tx.value.toNumber(),\n            input: tx.data,\n            from: this.wallet.address,\n            signedTransaction: signedTx,\n            signer: this.wallet.address\n        };\n    }\n\n    private async simulateBundle(bundle: BundleEntry[], blockNumber: number): Promise<void> {\n        const stringBundle = bundle.map(entry => entry.signedTransaction);\n        const simulation = await this.flashbotsProvider.simulate(stringBundle, blockNumber);\n\n        if ('error' in simulation) {\n            throw new Error(`Simulation failed: ${simulation.error.message}`);\n        }\n\n        // Verify profitability\n        const { bundleGasPrice, coinbaseDiff, totalGasUsed } = simulation;\n        const cost = bundleGasPrice.mul(totalGasUsed);\n        const profit = coinbaseDiff.sub(cost);\n\n        if (profit.lte(this.thresholds.minProfitThreshold)) {\n            throw new Error(\"Bundle not profitable enough\");\n        }\n    }\n\n    async submitBundleWithAdjustedGasPrice(bundle: BundleEntry[], blockNumber: number, blocksApi: any): Promise<void> {\n        elizaLogger.log(`Submitting bundle with adjusted gas price for block ${blockNumber}`);\n        \n        try {\n            // Get current gas prices\n            const { currentGasPrice, avgGasPrice } = await getGasPriceInfo(this.wallet.provider as Provider);\n            \n            // Monitor competing bundles\n            const competingBundlesGasPrices = await monitorCompetingBundlesGasPrices(blocksApi);\n            let competingBundleGasPrice = BigNumber.from(0);\n            \n            // Find highest competing gas price\n            for (const price of competingBundlesGasPrices) {\n                const currentPrice = BigNumber.from(price);\n                if (currentPrice.gt(competingBundleGasPrice)) {\n                    competingBundleGasPrice = currentPrice;\n                }\n            }\n\n            // Calculate adjusted gas price\n            const adjustedGasPrice = await this.adjustGasPriceForTransaction(\n                currentGasPrice,\n                avgGasPrice,\n                competingBundleGasPrice\n            );\n\n            // Validate adjusted gas price\n            if (adjustedGasPrice.lte(currentGasPrice)) {\n                throw new Error(\"Adjusted gas price is not competitive\");\n            }\n\n            // Validate bundle gas\n            const isValidBundleGas = await checkBundleGas(adjustedGasPrice);\n            if (!isValidBundleGas) {\n                throw new Error(\"Invalid bundle gas\");\n            }\n\n            // Set submission window\n            const currentTimestamp = Math.floor(Date.now() / 1000);\n            const maxTimestamp = currentTimestamp + 60; // 1 minute window\n\n            // Submit bundle\n            const targetBlockNumber = blockNumber + 1;\n            const bundleSubmission = await this.flashbotsProvider.sendBundle(\n                bundle.map(entry => ({\n                    signedTransaction: entry.signedTransaction,\n                    signer: this.wallet,\n                    transaction: {\n                        to: entry.to,\n                        gasLimit: entry.gas,\n                        gasPrice: entry.gas_price,\n                        value: entry.value,\n                        data: entry.input\n                    }\n                })),\n                targetBlockNumber,\n                {\n                    minTimestamp: currentTimestamp,\n                    maxTimestamp: maxTimestamp\n                }\n            );\n\n            // Check submission result\n            if ('error' in bundleSubmission) {\n                throw new Error(`Bundle submission failed: ${bundleSubmission.error.message}`);\n            }\n\n            elizaLogger.log(\"Bundle submitted successfully:\", {\n                blockNumber: targetBlockNumber,\n                adjustedGasPrice: adjustedGasPrice.toString(),\n                bundleHash: bundleSubmission.bundleHash\n            });\n\n        } catch (error) {\n            console.error(\"Failed to submit bundle with adjusted gas price:\", error);\n            throw error;\n        }\n    }\n\n    private async adjustGasPriceForTransaction(\n        currentGasPrice: BigNumber,\n        avgGasPrice: BigNumber,\n        competingBundleGasPrice: BigNumber\n    ): Promise<BigNumber> {\n        elizaLogger.log(\"Calculating adjusted gas price\", {\n            current: currentGasPrice.toString(),\n            average: avgGasPrice.toString(),\n            competing: competingBundleGasPrice.toString()\n        });\n\n        // Find highest gas price\n        let adjustedGasPrice = currentGasPrice;\n        if (avgGasPrice.gt(adjustedGasPrice)) {\n            adjustedGasPrice = avgGasPrice;\n        }\n        if (competingBundleGasPrice.gt(adjustedGasPrice)) {\n            adjustedGasPrice = competingBundleGasPrice;\n        }\n\n        // Add premium to ensure priority (10% increase)\n        const premium = adjustedGasPrice.mul(10).div(100);\n        adjustedGasPrice = adjustedGasPrice.add(premium);\n\n        elizaLogger.log(\"Adjusted gas price:\", adjustedGasPrice.toString());\n        return adjustedGasPrice;\n    }\n\n    private async calculateOptimalVolume(\n        buyFromMarket: MarketType,\n        sellToMarket: MarketType,\n        tokenAddress: string,\n        profit: BigNumber\n    ): Promise<BigNumber> {\n        elizaLogger.log(\"Entering calculateOptimalVolume\");\n\n        // Determine the available liquidity in both markets\n        const availableLiquidityBuy = await buyFromMarket.getReserves(tokenAddress);\n        const availableLiquiditySell = await sellToMarket.getReserves(tokenAddress);\n\n        // Set a maximum trade size limit to manage risk\n        const maxTradeSize = BigNumber.from(100000); // Adjust as needed\n\n        // Calculate price impacts and trading fees\n        const priceImpactBuy = await buyFromMarket.getPriceImpact(tokenAddress, maxTradeSize);\n        const priceImpactSell = await sellToMarket.getPriceImpact(tokenAddress, maxTradeSize);\n\n        const tradingFeeBuy = await buyFromMarket.getTradingFee(tokenAddress);\n        const tradingFeeSell = await sellToMarket.getTradingFee(tokenAddress);\n\n        // Binary Search Initialization\n        let left = BigNumber.from(1);\n        let right = maxTradeSize;\n        let optimalVolume = BigNumber.from(0);\n        let maxExpectedProfit = BigNumber.from(0);\n\n        while (left.lt(right)) {\n            const mid = left.add(right).div(2);\n\n            // Calculate expected profit at mid\n            const expectedProfit = profit\n                .mul(mid)\n                .sub(priceImpactBuy.mul(mid))\n                .sub(priceImpactSell.mul(mid))\n                .sub(tradingFeeBuy.mul(mid))\n                .sub(tradingFeeSell.mul(mid));\n\n            if (expectedProfit.gt(maxExpectedProfit) && expectedProfit.gte(this.thresholds.minProfitThreshold)) {\n                maxExpectedProfit = expectedProfit;\n                optimalVolume = mid;\n                left = mid.add(1);\n            } else {\n                right = mid.sub(1);\n            }\n        }\n\n        // Ensure that the optimal volume does not exceed available liquidity\n        optimalVolume = BigNumber.from(Math.min(\n            optimalVolume.toNumber(),\n            availableLiquidityBuy.toNumber(),\n            availableLiquiditySell.toNumber()\n        ));\n\n        elizaLogger.log(`calculateOptimalVolume: optimalVolume = ${optimalVolume}`);\n        return optimalVolume;\n    }\n}\n\n// Helper functions\nasync function checkBundleGas(bundleGas: BigNumber): Promise<boolean> {\n    const isValid = bundleGas.gte(42000);\n    elizaLogger.log(`checkBundleGas: bundleGas = ${bundleGas}, isValid = ${isValid}`);\n    return isValid;\n}\n\nexport async function monitorCompetingBundlesGasPrices(blocksApi: { getRecentBlocks: () => any; }): Promise<Array<BigNumber>> {\n    elizaLogger.log(\"Entering monitorCompetingBundlesGasPrices\");\n    const recentBlocks = await blocksApi.getRecentBlocks();\n    const competingBundlesGasPrices = recentBlocks.map((block: { bundleGasPrice: any; }) => block.bundleGasPrice);\n    elizaLogger.log(`monitorCompetingBundlesGasPrices: competingBundlesGasPrices = ${competingBundlesGasPrices}`);\n    return competingBundlesGasPrices;\n}\n\nexport async function getGasPriceInfo(provider: Provider): Promise<{ \n    currentGasPrice: BigNumber, \n    avgGasPrice: BigNumber \n}> {\n    const feeData = await provider.getFeeData();\n    const currentGasPrice = feeData.gasPrice || BigNumber.from(0);\n    \n    // Get average from last few blocks\n    const block = await provider.getBlock(\"latest\");\n    const prices: BigNumber[] = [];\n    for (let i = 0; i < 5; i++) {\n        const historicalBlock = await provider.getBlock(block.number - i);\n        if (historicalBlock.baseFeePerGas) {\n            prices.push(historicalBlock.baseFeePerGas);\n        }\n    }\n    \n    const avgGasPrice = prices.length > 0 \n        ? prices.reduce((a, b) => a.add(b)).div(prices.length)\n        : currentGasPrice;\n\n    return { currentGasPrice, avgGasPrice };\n}\n\nexport async function calculateOptimalVolume(\n    buyFromMarket: MarketType,\n    sellToMarket: MarketType,\n    tokenAddress: string,\n    profit: BigNumber\n): Promise<BigNumber> {\n    const buyLiquidity = await buyFromMarket.getReserves(tokenAddress);\n    const sellLiquidity = await sellToMarket.getReserves(tokenAddress);\n    \n    // Start with 1% of the smaller liquidity pool\n    let optimalVolume = buyLiquidity.lt(sellLiquidity) \n        ? buyLiquidity.div(100)\n        : sellLiquidity.div(100);\n\n    // Adjust based on price impact\n    const buyImpact = await buyFromMarket.getPriceImpact(tokenAddress, optimalVolume);\n    const sellImpact = await sellToMarket.getPriceImpact(tokenAddress, optimalVolume);\n    \n    // If price impact is too high, reduce volume\n    if (buyImpact.add(sellImpact).gt(BigNumber.from(300))) { // 3% total impact\n        optimalVolume = optimalVolume.mul(80).div(100); // Reduce by 20%\n    }\n\n    return optimalVolume;\n}","import { Service, ServiceType, IAgentRuntime } from \"@elizaos/core\";\nimport { Arbitrage } from \"../core/Arbitrage\";\nimport { WebSocket } from 'ws';\nimport { CrossedMarketDetails, MarketsByToken } from \"../type\";\nimport { WebSocketProvider } from \"@ethersproject/providers\";\nimport { Wallet } from \"@ethersproject/wallet\";\nimport { FlashbotsBundleProvider } from \"@flashbots/ethers-provider-bundle\";\nimport { Contract } from \"@ethersproject/contracts\";\n\n// Declare the ARBITRAGE service type\ndeclare module \"@elizaos/core\" {\n    interface ServiceTypeMap {\n        arbitrage: Service & ArbitrageService;\n    }\n\n    export enum ServiceType {\n        ARBITRAGE = \"arbitrage\"\n    }\n}\n\nexport class ArbitrageService extends Service {\n    private arbitrage: Arbitrage | null = null;\n    private wsConnection: WebSocket | null = null;\n    private marketsByToken = {};\n    private currentBlock = 0;\n    private runtime!: IAgentRuntime;\n\n    static get serviceType(): ServiceType {\n        return ServiceType.ARBITRAGE;\n    }\n\n    get serviceType(): ServiceType {\n        return ServiceType.ARBITRAGE;\n    }\n\n    // Remove unnecessary constructor\n    // constructor() {\n    //     super();\n    // }\n\n    async initialize(runtime: IAgentRuntime): Promise<void> {\n        this.runtime = runtime;\n\n        // Get WebSocket URL with multiple fallback options\n        let wsUrl = runtime.getSetting(\"ARBITRAGE_ETHEREUM_WS_URL\")\n\n        let rpcUrl = runtime.getSetting(\"ARBITRAGE_EVM_PROVIDER_URL\") \n                    \n\n        // Debug logging\n        console.log('ArbitrageService initialize - URLs:', {\n            wsUrl,\n            rpcUrl\n        });\n\n        if (!wsUrl && !rpcUrl) {\n            throw new Error(\"Missing both ARBITRAGE_ETHEREUM_WS_URL and ARBITRAGE_EVM_PROVIDER_URL envs\");\n        }\n\n        // If we only have RPC URL, derive WS URL\n        if (!wsUrl && rpcUrl) {\n            wsUrl = rpcUrl.replace('https://', 'wss://');\n            console.log('Using derived WebSocket URL:', wsUrl);\n        }\n\n        if (!wsUrl) {\n            throw new Error(\"No WebSocket URL available after all fallbacks\");\n        }\n\n        // Initialize wallet and providers\n        const walletKey = runtime.getSetting(\"ARBITRAGE_EVM_PRIVATE_KEY\") \n        if (!walletKey) throw new Error(\"Missing ARBITRAGE_EVM_PRIVATE_KEY env\");\n\n        // Initialize provider\n        console.log('Initializing WebSocketProvider with URL:', wsUrl);\n        const provider = new WebSocketProvider(wsUrl as string);\n        const wallet = new Wallet(walletKey, provider);\n\n        // Initialize Flashbots provider\n        const flashbotsKey = runtime.getSetting(\"FLASHBOTS_RELAY_SIGNING_KEY\") \n        if (!flashbotsKey) throw new Error(\"Missing FLASHBOTS_RELAY_SIGNING_KEY env\");\n\n        const flashbotsProvider = await FlashbotsBundleProvider.create(\n            provider,\n            wallet,\n            flashbotsKey\n        );\n\n        // Initialize bundle executor contract\n        const bundleExecutorAddress = runtime.getSetting(\"BUNDLE_EXECUTOR_ADDRESS\");\n        if (!bundleExecutorAddress) throw new Error(\"Missing BUNDLE_EXECUTOR_ADDRESS env\");\n\n        // Create Contract instance\n        const bundleExecutorContract = new Contract(\n            bundleExecutorAddress,\n            [\n                'function execute(bytes[] calldata calls) external payable',\n                'function executeWithToken(bytes[] calldata calls, address tokenAddress, uint256 tokenAmount) external payable'\n            ],\n            wallet\n        );\n\n        // Initialize Arbitrage instance with Contract instance\n        this.arbitrage = new Arbitrage(\n            wallet,\n            flashbotsProvider,\n            bundleExecutorContract\n        );\n\n        // Setup WebSocket connection\n        console.log('Setting up WebSocket connection to:', wsUrl);\n        this.wsConnection = new WebSocket(wsUrl);\n        this.setupWebSocketHandlers();\n    }\n\n    private setupWebSocketHandlers(): void {\n        if (!this.wsConnection) return;\n\n        this.wsConnection.on('open', () => {\n            console.log('WebSocket connection established');\n            // Subscribe to new blocks\n            this.wsConnection?.send(JSON.stringify({\n                jsonrpc: '2.0',\n                id: 1,\n                method: 'eth_subscribe',\n                params: ['newHeads']\n            }));\n        });\n\n        this.wsConnection.on('message', async (data: string) => {\n            const message = JSON.parse(data);\n            if (message.params?.result?.number) {\n                this.currentBlock = Number.parseInt(message.params.result.number, 16);\n            }\n        });\n\n        this.wsConnection.on('error', (error) => {\n            console.error('WebSocket error:', error);\n        });\n\n        this.wsConnection.on('close', () => {\n            console.log('WebSocket connection closed');\n            // Attempt to reconnect after a delay\n            setTimeout(() => this.initialize(this.runtime), 5000);\n        });\n    }\n\n    async evaluateMarkets(): Promise<CrossedMarketDetails[]> {\n        if (!this.arbitrage) throw new Error(\"ArbitrageService not initialized\");\n        return this.arbitrage.evaluateMarkets(this.marketsByToken);\n    }\n\n    async executeArbitrage(markets: CrossedMarketDetails[]): Promise<void> {\n        if (!this.arbitrage) throw new Error(\"ArbitrageService not initialized\");\n        const maxAttempts = 10;\n        return this.arbitrage.takeCrossedMarkets(markets, this.currentBlock, maxAttempts);\n    }\n\n    async stop(): Promise<void> {\n        if (this.wsConnection) {\n            this.wsConnection.close();\n            this.wsConnection = null;\n        }\n    }\n}","import { Plugin, Action, Provider, IAgentRuntime } from \"@elizaos/core\";\nimport { executeArbitrageAction } from \"./actions/arbitrageAction\";\nimport { marketProvider } from \"./providers/marketProvider\";\nimport { ArbitrageService } from \"./services/ArbitrageService\";\n// Create a single instance of the service\n\nconst arbitrageService = new ArbitrageService();\n\nconst arbitragePlugin: Plugin = {\n    name: \"arbitrage-plugin\",\n    description: \"Automated arbitrage trading plugin\",\n    actions: [executeArbitrageAction],\n    providers: [marketProvider],\n    services: [arbitrageService]\n};\n\nexport default arbitragePlugin;"]}